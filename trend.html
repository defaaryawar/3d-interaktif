<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Magic Particles - Smooth & Clear</title>
    <style>
        * { box-sizing: border-box; }
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; 
            font-family: 'Segoe UI', sans-serif;
            color: white;
        }



        #input-video { display: none; }
        
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #020202;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.8s ease-out;
            color: white;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            border-top-color: #00ffff;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div style="font-size: 14px; letter-spacing: 1px;">MEMUAT SISTEM PARTIKEL...</div>
        <div style="font-size: 11px; color:#666; margin-top:8px">Izinkan akses kamera untuk memulai</div>
    </div>



    <div id="canvas-container"></div>
    <video id="input-video"></video>

    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 20000; // Increased even more for maximum density
        const PARTICLE_SIZE = 0.5; // Slightly larger for clarity
        const TEXT_SAMPLE_DENSITY = 3; // Lower = tighter sampling = sharper text
        const LERP_SPEED = 0.035; // Very slow and smooth transition
        
        // --- STATE ---
        const state = {
            gesture: 'idle', // idle, fist, open, point1, point2
            targetPoints: [],
            isHandDetected: false,
            time: 0
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.008); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 60;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3); // Where particles want to go
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const randomOffsets = new Float32Array(PARTICLE_COUNT * 3);

        const colorStart = new THREE.Color(0x00aaff);
        const colorEnd = new THREE.Color(0xff00aa);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // Initial chaotic positions
            positions[i*3] = (Math.random() - 0.5) * 200;
            positions[i*3+1] = (Math.random() - 0.5) * 200;
            positions[i*3+2] = (Math.random() - 0.5) * 200;

            randomOffsets[i*3] = Math.random();
            randomOffsets[i*3+1] = Math.random();
            randomOffsets[i*3+2] = Math.random();

            // color gradient - boosted brightness
            const mix = Math.random();
            const col = colorStart.clone().lerp(colorEnd, mix);
            // Boost color to make it neon
            col.r = Math.min(1, col.r * 1.5);
            col.g = Math.min(1, col.g * 1.5);
            col.b = Math.min(1, col.b * 1.5);
            
            colors[i*3] = col.r;
            colors[i*3+1] = col.g;
            colors[i*3+2] = col.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Helper to generate high-contrast spark texture
        function generateSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');       // Core is pure white
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');   // Bright halo
            gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.2)');   // Outer glow
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');             // Fade out
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE * 1.5, // Slightly larger for better visibility
            vertexColors: true,
            map: generateSprite(),
            transparent: true,
            opacity: 1.0,        // Full opacity
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);


        // --- SHAPE GENERATION LOGIC ---

        function createTextPoints(textLines, fontSize) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = 2048; // High res for crisp text
            const height = 1024;
            canvas.width = width;
            canvas.height = height;

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, width, height);
            
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            ctx.font = `900 ${fontSize}px "Segoe UI", sans-serif`;

            // Draw multiple lines if array is passed
            const lineHeight = fontSize * 1.2;
            const startY = (height - (textLines.length - 1) * lineHeight) / 2;

            textLines.forEach((line, index) => {
                ctx.fillText(line.toUpperCase(), width/2, startY + index * lineHeight);
            });

            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const points = [];

            // Scan pixels
            // We flip Y to match WebGL coordinates
            for (let y = 0; y < height; y += TEXT_SAMPLE_DENSITY) {
                for (let x = 0; x < width; x += TEXT_SAMPLE_DENSITY) {
                    if (data[(y * width + x) * 4] > 128) { // Threshold
                        points.push({
                            x: (x - width/2) * 0.08, // Scale down to world units
                            y: -(y - height/2) * 0.08, 
                            z: 0
                        });
                    }
                }
            }
            return points;
        }

        // Precompute shapes
        const shapes = {
            sphere: [], // Dynamic
            fist: [],   // Dynamic implosion
            hello: createTextPoints(['HELLO'], 350),
            name: createTextPoints(['NAJMITA', 'ZAHIRA', 'DIRGANTORO'], 160),
            love: createTextPoints(['I LOVE YOUUU', 'SOOO MUCHH <3'], 180)
        };

        function updateTargetPositions() {
            const time = state.time;
            
            // Mode: IDLE (Slow floating cloud/sphere)
            if (state.gesture === 'idle') {
                const radius = 30; // Bigger idle sphere
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const u = randomOffsets[i*3];
                    const v = randomOffsets[i*3+1];
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    
                    // Breathing sphere
                    const r = radius + Math.sin(time * 0.5 + u * 10) * 5;
                    
                    targetPositions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    targetPositions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                    targetPositions[i*3+2] = r * Math.cos(phi);
                }
            }
            // Mode: FIST (Implosion / Black Hole)
            else if (state.gesture === 'fist') {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    // Pull to center but with a swirl
                    const angle = i * 0.1 + time * 2;
                    const radius = 2 + randomOffsets[i*3] * 3; // Tight core
                    
                    targetPositions[i*3] = Math.cos(angle) * radius;
                    targetPositions[i*3+1] = Math.sin(angle) * radius;
                    targetPositions[i*3+2] = (randomOffsets[i*3+2] - 0.5) * 5; // Flat discish
                }
            }
            // Mode: OPEN (Galaxy Spiral)
            else if (state.gesture === 'open') {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const angle = i * 0.02 + time * 0.5;
                    const radius = i * 0.01 + 5; // Spiraling out
                    
                    // Spiral equation
                    const x = Math.cos(angle) * radius * 4;
                    const y = Math.sin(angle) * radius * 4; // Flat spiral on XY plan roughly
                     
                    targetPositions[i*3] = x;
                    targetPositions[i*3+1] = y;
                    targetPositions[i*3+2] = (randomOffsets[i*3+2] - 0.5) * 10; // Some thickness
                }
            }
            // Mode: TEXT (Hello / Name / Love)
            else if (state.gesture === 'point1' || state.gesture === 'point2' || state.gesture === 'point3') {
                let shape = shapes.hello;
                if (state.gesture === 'point2') shape = shapes.name;
                if (state.gesture === 'point3') shape = shapes.love;

                const len = shape.length;
                
                if (len > 0) {
                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        // Map particle to a text point. Wrap around if more particles than points.
                        const pt = shape[i % len];
                        
                        // Add organic subtle movement so text isn't dead static
                        const wobbleX = Math.sin(time * 2 + i) * 0.2;
                        const wobbleY = Math.cos(time * 1.5 + i) * 0.2;

                        targetPositions[i*3] = pt.x + wobbleX;
                        targetPositions[i*3+1] = pt.y + wobbleY;
                        
                         // If we have EXCESS particles, make them float in background
                        if (i >= len) {
                             targetPositions[i*3+2] = (Math.random() - 0.5) * 50 - 20; // Push back
                        } else {
                             targetPositions[i*3+2] = pt.z;
                        }
                    }
                }
            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            state.time += 0.01;
            
            updateTargetPositions();

            // Smooth Interpolation
            const current = geometry.attributes.position.array;
            
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                // Determine speed based on distance for "arrive" behavior
                const dist = targetPositions[i] - current[i];
                // Simple exponential ease out
                current[i] += dist * LERP_SPEED;
            }

            geometry.attributes.position.needsUpdate = true;
            
            // Subtle camera sway
            camera.position.x = Math.sin(state.time * 0.2) * 5;
            camera.position.y = Math.cos(state.time * 0.2) * 5;
            camera.lookAt(0,0,0);

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();

        // --- GESTURE RECOGNITION ---

        function detectGesture(landmarks) {
            // Finger Tips
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];

            // Finger Bases (PIP/MCP) for folded detection
            const thumbBase = landmarks[2]; 
            const indexBase = landmarks[6];
            const middleBase = landmarks[10];
            const ringBase = landmarks[14];
            const pinkyBase = landmarks[18];

            // Check which fingers are extended (Tip above base - note Y increases downwards)
            // We use a simple logic: if Tip Y < Base Y (higher on screen), it's extended.
            // Note: This assumes hand is roughly upright. 
            
            const isIndexUp = indexTip.y < indexBase.y;
            const isMiddleUp = middleTip.y < middleBase.y;
            const isRingUp = ringTip.y < ringBase.y;
            const isPinkyUp = pinkyTip.y < pinkyBase.y;
            
            // Count extended fingers (excluding thumb for simplicity in 1 vs 2)
            let extendedCount = 0;
            if (isIndexUp) extendedCount++;
            if (isMiddleUp) extendedCount++;
            if (isRingUp) extendedCount++;
            if (isPinkyUp) extendedCount++;

            // FIST: 0 fingers extended
            if (extendedCount === 0) return 'fist';
            
            // OPEN: 4 fingers extended (thumb is tricky, ignore for now)
            if (extendedCount >= 4) return 'open';
            
            // 1 FINGER
            if (extendedCount === 1) return 'point1'; // Index only usually, but let's be generous
            
            // 2 FINGERS
            if (extendedCount === 2) return 'point2';
            
            // 3 FINGERS
            if (extendedCount === 3) return 'point3';

            return 'idle'; // Fallback
        }

        function onResults(results) {
            const statusText = document.getElementById('status-text');
            const statusDot = document.getElementById('status-dot');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.isHandDetected = true;
                statusDot.classList.add('active');

                const landmarks = results.multiHandLandmarks[0];
                const gesture = detectGesture(landmarks);
                
                // Debounce / State holding could be added here if flickering occurs
                // For now, direct mapping usually feels responsive enough
                
                state.gesture = gesture;

                // UI Feedback
                let label = "Terdeteksi";
                switch(gesture) {
                    case 'fist': label = "Genggaman (Black Hole)"; break;
                    case 'open': label = "Terbuka (Galaxy)"; break;
                    case 'point1': label = "1 Jari: HELLO"; break;
                    case 'point2': label = "2 Jari: NAJMITA..."; break;
                    case 'point3': label = "3 Jari: LOVE YOU..."; break;
                    default: label = "Gerakkan Tangan...";
                }
                statusText.innerText = label;

            } else {
                state.isHandDetected = false;
                state.gesture = 'idle';
                statusDot.classList.remove('active');
                statusText.innerText = "Mencari Tangan...";
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        hands.onResults(onResults);

        const videoElement = document.getElementById('input-video');
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        cameraUtils.start().then(() => {
            const loader = document.getElementById('loader');
            loader.style.opacity = '0';
            setTimeout(() => loader.style.display = 'none', 800);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
